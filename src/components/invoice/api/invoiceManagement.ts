// src/components/invoice/api/invoiceManagement.ts
// API for invoice management including automated generation from orders
import { supabase } from '@/integrations/supabase/client';
import { logger } from '@/utils/logger';
import { toSafeISOString, UserFriendlyDate } from '@/utils/unifiedDateUtils';

// Types for invoice management
export interface CreateInvoiceParams {
  orderId?: string;
  customerName: string;
  customerEmail?: string;
  customerPhone?: string;
  customerAddress?: string;
  items: InvoiceItemInput[];
  templateType?: 'modern' | 'classic' | 'minimal';
  notes?: string;
  paymentInstructions?: string;
  dueDate?: Date;
}

export interface InvoiceItemInput {
  itemName: string;
  description?: string;
  quantity: number;
  unitPrice: number;
}

export interface Invoice {
  id: string;
  invoiceNumber: string;
  orderId?: string;
  customerName: string;
  customerEmail?: string;
  customerPhone?: string;
  customerAddress?: string;
  issueDate: Date;
  dueDate?: Date;
  subtotal: number;
  discountAmount: number;
  discountPercentage: number;
  taxAmount: number;
  taxPercentage: number;
  shippingAmount: number;
  totalAmount: number;
  status: 'draft' | 'sent' | 'paid' | 'overdue' | 'cancelled';
  currency: string;
  notes?: string;
  paymentInstructions?: string;
  autoGenerated: boolean;
  templateType: 'modern' | 'classic' | 'minimal';
  items: InvoiceItem[];
  createdAt: Date;
  updatedAt: Date;
}

export interface InvoiceItem {
  id: string;
  itemName: string;
  description?: string;
  quantity: number;
  unitPrice: number;
  totalPrice: number;
  sortOrder: number;
}

/**
 * Generate invoice automatically from order
 */
export const generateInvoiceFromOrder = async (orderId: string): Promise<Invoice> => {
  logger.context('InvoiceAPI', 'Generating invoice from order:', orderId);
  
  try {
    // Call the Supabase function to create invoice from order
    const { data, error } = await supabase.rpc('create_invoice_from_order', {
      p_order_id: orderId,
      p_template_type: 'modern'
    });

    if (error) {
      logger.error('InvoiceAPI', 'Error creating invoice from order:', error);
      throw new Error('Gagal membuat invoice otomatis: ' + error.message);
    }

    if (!data) {
      throw new Error('Tidak ada data invoice yang dikembalikan');
    }

    // Fetch the created invoice with its items
    const invoice = await getInvoiceById(data);
    logger.success('InvoiceAPI', 'Invoice generated successfully from order:', orderId);
    
    return invoice;
  } catch (error) {
    logger.error('InvoiceAPI', 'Failed to generate invoice from order:', error);
    throw error;
  }
};

/**
 * Create invoice manually
 */
export const createInvoice = async (params: CreateInvoiceParams): Promise<Invoice> => {
  logger.context('InvoiceAPI', 'Creating manual invoice');
  
  try {
    const { data: user } = await supabase.auth.getUser();
    if (!user.user) {
      throw new Error('User not authenticated');
    }

    // Calculate totals
    const subtotal = params.items.reduce((sum, item) => sum + (item.quantity * item.unitPrice), 0);
    const totalAmount = subtotal; // Can add tax/discount calculations later

    // First, create the invoice
    const { data: invoiceData, error: invoiceError } = await supabase
      .from('invoices')
      .insert({
        user_id: user.user.id,
        order_id: params.orderId || null,
        customer_name: params.customerName,
        customer_email: params.customerEmail || null,
        customer_phone: params.customerPhone || null,
        customer_address: params.customerAddress || null,
        issue_date: toSafeISOString(new Date()) || new Date().toISOString(),
        due_date: params.dueDate ? toSafeISOString(params.dueDate) : null,
        subtotal,
        total_amount: totalAmount,
        template_type: params.templateType || 'modern',
        notes: params.notes || null,
        payment_instructions: params.paymentInstructions || null,
        auto_generated: false
      })
      .select()
      .single();

    if (invoiceError) {
      logger.error('InvoiceAPI', 'Error creating invoice:', invoiceError);
      throw new Error('Gagal membuat invoice: ' + invoiceError.message);
    }

    // Then, create the invoice items
    const invoiceItems = params.items.map((item, index) => ({
      invoice_id: invoiceData.id,
      item_name: item.itemName,
      description: item.description || null,
      quantity: item.quantity,
      unit_price: item.unitPrice,
      total_price: item.quantity * item.unitPrice,
      sort_order: index
    }));

    const { error: itemsError } = await supabase
      .from('invoice_items')
      .insert(invoiceItems);

    if (itemsError) {
      logger.error('InvoiceAPI', 'Error creating invoice items:', itemsError);
      // Clean up the created invoice
      await supabase.from('invoices').delete().eq('id', invoiceData.id);
      throw new Error('Gagal membuat item invoice: ' + itemsError.message);
    }

    // Fetch the complete invoice
    const invoice = await getInvoiceById(invoiceData.id);
    logger.success('InvoiceAPI', 'Invoice created successfully:', invoice.invoiceNumber);
    
    return invoice;
  } catch (error) {
    logger.error('InvoiceAPI', 'Failed to create invoice:', error);
    throw error;
  }
};

/**
 * Get invoice by ID with items
 */
export const getInvoiceById = async (invoiceId: string): Promise<Invoice> => {
  logger.context('InvoiceAPI', 'Fetching invoice:', invoiceId);
  
  try {
    // Fetch invoice
    const { data: invoiceData, error: invoiceError } = await supabase
      .from('invoices')
      .select(`
        *,
        invoice_items (*)
      `)
      .eq('id', invoiceId)
      .single();

    if (invoiceError) {
      logger.error('InvoiceAPI', 'Error fetching invoice:', invoiceError);
      throw new Error('Gagal mengambil data invoice: ' + invoiceError.message);
    }

    if (!invoiceData) {
      throw new Error('Invoice tidak ditemukan');
    }

    // Transform to our Invoice type
    const invoice: Invoice = {
      id: invoiceData.id,
      invoiceNumber: invoiceData.invoice_number,
      orderId: invoiceData.order_id || undefined,
      customerName: invoiceData.customer_name,
      customerEmail: invoiceData.customer_email || undefined,
      customerPhone: invoiceData.customer_phone || undefined,
      customerAddress: invoiceData.customer_address || undefined,
      issueDate: UserFriendlyDate.safeParseToDate(invoiceData.issue_date) || new Date(),
      dueDate: invoiceData.due_date ? UserFriendlyDate.safeParseToDate(invoiceData.due_date) : undefined,
      subtotal: invoiceData.subtotal,
      discountAmount: invoiceData.discount_amount || 0,
      discountPercentage: invoiceData.discount_percentage || 0,
      taxAmount: invoiceData.tax_amount || 0,
      taxPercentage: invoiceData.tax_percentage || 0,
      shippingAmount: invoiceData.shipping_amount || 0,
      totalAmount: invoiceData.total_amount,
      status: invoiceData.status as Invoice['status'],
      currency: invoiceData.currency,
      notes: invoiceData.notes || undefined,
      paymentInstructions: invoiceData.payment_instructions || undefined,
      autoGenerated: invoiceData.auto_generated,
      templateType: invoiceData.template_type as Invoice['templateType'],
      items: (invoiceData.invoice_items || [])
        .sort((a: any, b: any) => a.sort_order - b.sort_order)
        .map((item: any) => ({
          id: item.id,
          itemName: item.item_name,
          description: item.description || undefined,
          quantity: item.quantity,
          unitPrice: item.unit_price,
          totalPrice: item.total_price,
          sortOrder: item.sort_order
        })),
      createdAt: UserFriendlyDate.safeParseToDate(invoiceData.created_at) || new Date(),
      updatedAt: UserFriendlyDate.safeParseToDate(invoiceData.updated_at) || new Date()
    };

    logger.success('InvoiceAPI', 'Invoice fetched successfully:', invoice.invoiceNumber);
    return invoice;
  } catch (error) {
    logger.error('InvoiceAPI', 'Failed to fetch invoice:', error);
    throw error;
  }
};

/**
 * Get all invoices for current user
 */
export const getUserInvoices = async (limit: number = 20, offset: number = 0): Promise<Invoice[]> => {
  logger.context('InvoiceAPI', 'Fetching user invoices');
  
  try {
    const { data, error } = await supabase
      .from('invoices')
      .select(`
        *,
        invoice_items (*)
      `)
      .order('created_at', { ascending: false })
      .range(offset, offset + limit - 1);

    if (error) {
      logger.error('InvoiceAPI', 'Error fetching invoices:', error);
      throw new Error('Gagal mengambil daftar invoice: ' + error.message);
    }

    const invoices: Invoice[] = (data || []).map(invoiceData => ({
      id: invoiceData.id,
      invoiceNumber: invoiceData.invoice_number,
      orderId: invoiceData.order_id || undefined,
      customerName: invoiceData.customer_name,
      customerEmail: invoiceData.customer_email || undefined,
      customerPhone: invoiceData.customer_phone || undefined,
      customerAddress: invoiceData.customer_address || undefined,
      issueDate: UserFriendlyDate.safeParseToDate(invoiceData.issue_date) || new Date(),
      dueDate: invoiceData.due_date ? UserFriendlyDate.safeParseToDate(invoiceData.due_date) : undefined,
      subtotal: invoiceData.subtotal,
      discountAmount: invoiceData.discount_amount || 0,
      discountPercentage: invoiceData.discount_percentage || 0,
      taxAmount: invoiceData.tax_amount || 0,
      taxPercentage: invoiceData.tax_percentage || 0,
      shippingAmount: invoiceData.shipping_amount || 0,
      totalAmount: invoiceData.total_amount,
      status: invoiceData.status as Invoice['status'],
      currency: invoiceData.currency,
      notes: invoiceData.notes || undefined,
      paymentInstructions: invoiceData.payment_instructions || undefined,
      autoGenerated: invoiceData.auto_generated,
      templateType: invoiceData.template_type as Invoice['templateType'],
      items: (invoiceData.invoice_items || [])
        .sort((a: any, b: any) => a.sort_order - b.sort_order)
        .map((item: any) => ({
          id: item.id,
          itemName: item.item_name,
          description: item.description || undefined,
          quantity: item.quantity,
          unitPrice: item.unit_price,
          totalPrice: item.total_price,
          sortOrder: item.sort_order
        })),
      createdAt: UserFriendlyDate.safeParseToDate(invoiceData.created_at) || new Date(),
      updatedAt: UserFriendlyDate.safeParseToDate(invoiceData.updated_at) || new Date()
    }));

    logger.success('InvoiceAPI', `Fetched ${invoices.length} invoices`);
    return invoices;
  } catch (error) {
    logger.error('InvoiceAPI', 'Failed to fetch invoices:', error);
    throw error;
  }
};

/**
 * Update invoice status
 */
export const updateInvoiceStatus = async (
  invoiceId: string, 
  status: Invoice['status']
): Promise<void> => {
  logger.context('InvoiceAPI', 'Updating invoice status:', { invoiceId, status });
  
  try {
    const { error } = await supabase
      .from('invoices')
      .update({ status })
      .eq('id', invoiceId);

    if (error) {
      logger.error('InvoiceAPI', 'Error updating invoice status:', error);
      throw new Error('Gagal mengupdate status invoice: ' + error.message);
    }

    logger.success('InvoiceAPI', 'Invoice status updated successfully');
  } catch (error) {
    logger.error('InvoiceAPI', 'Failed to update invoice status:', error);
    throw error;
  }
};

/**
 * Delete invoice
 */
export const deleteInvoice = async (invoiceId: string): Promise<void> => {
  logger.context('InvoiceAPI', 'Deleting invoice:', invoiceId);
  
  try {
    const { error } = await supabase
      .from('invoices')
      .delete()
      .eq('id', invoiceId);

    if (error) {
      logger.error('InvoiceAPI', 'Error deleting invoice:', error);
      throw new Error('Gagal menghapus invoice: ' + error.message);
    }

    logger.success('InvoiceAPI', 'Invoice deleted successfully');
  } catch (error) {
    logger.error('InvoiceAPI', 'Failed to delete invoice:', error);
    throw error;
  }
};
