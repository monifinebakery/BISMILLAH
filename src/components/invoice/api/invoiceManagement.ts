import { supabase } from '@/integrations/supabase/client';
import { logger } from '@/utils/logger';
import { UserFriendlyDate } from '@/utils/userFriendlyDate';
import { toSafeISOString } from '@/utils/unifiedDateUtils';

// Types
export interface CreateInvoiceParams {
  orderId?: string;
  customerName: string;
  customerEmail?: string;
  customerPhone?: string;
  customerAddress?: string;
  issueDate?: string | Date;
  dueDate?: string | Date;
  items: InvoiceItemInput[];
  discount?: {
    type: 'percentage' | 'fixed';
    value: number;
  };
  tax?: {
    type: 'percentage' | 'fixed';
    value: number;
  };
  shippingAmount?: number;
  currency?: string;
  notes?: string;
  paymentInstructions?: string;
  autoGenerated?: boolean;
  templateType?: 'modern' | 'classic' | 'minimal';
}

export interface InvoiceItemInput {
  itemName: string;
  description?: string;
  quantity: number;
  unitPrice: number;
  productId?: string;
}

export interface Invoice {
  id: string;
  invoiceNumber: string;
  orderId?: string;
  customerName: string;
  customerEmail?: string;
  customerPhone?: string;
  customerAddress?: string;
  issueDate: Date;
  dueDate?: Date;
  subtotal: number;
  discountAmount: number;
  discountPercentage: number;
  taxAmount: number;
  taxPercentage: number;
  shippingAmount: number;
  totalAmount: number;
  status: 'draft' | 'sent' | 'paid' | 'overdue' | 'cancelled';
  currency: string;
  notes?: string;
  paymentInstructions?: string;
  autoGenerated: boolean;
  templateType: 'modern' | 'classic' | 'minimal';
  items: InvoiceItem[];
  createdAt: Date;
  updatedAt: Date;
}

export interface InvoiceItem {
  id: string;
  itemName: string;
  description?: string;
  quantity: number;
  unitPrice: number;
  totalPrice: number;
  sortOrder: number;
}

export interface InvoiceItemDB {
  id: string;
  invoice_id: string;
  item_name: string;
  description?: string;
  quantity: number;
  unit_price: number;
  total_price: number;
  product_id?: string;
  sort_order: number;
  created_at: string;
}

/**
 * Generate invoice from order
 */
export const generateInvoiceFromOrder = async (orderId: string): Promise<Invoice> => {
  logger.context('InvoiceAPI', 'Generating invoice from order:', orderId);
  
  try {
    // Get order data first - only needed fields
    const { data: orderData, error: orderError } = await supabase
      .from('orders')
      .select(`
        id,
        nama_pelanggan,
        email_pelanggan,
        telepon_pelanggan,
        alamat_pengiriman,
        items,
        total_pesanan
      `)
      .eq('id', orderId)
      .single();

    if (orderError || !orderData) {
      throw new Error('Order tidak ditemukan: ' + (orderError?.message || 'Data kosong'));
    }

    // Create invoice from order data
    const invoiceParams: CreateInvoiceParams = {
      orderId: orderId,
      customerName: orderData.nama_pelanggan || 'Customer',
      customerEmail: orderData.email_pelanggan || undefined,
      customerPhone: orderData.telepon_pelanggan || undefined,
      customerAddress: orderData.alamat_pengiriman || undefined,
      items: Array.isArray(orderData.items) ? (orderData.items as Record<string, unknown>[]).map((item: Record<string, unknown>) => ({
        itemName: String(item.nama_produk || item.name || 'Item'),
        description: item.deskripsi ? String(item.deskripsi) : item.description ? String(item.description) : undefined,
        quantity: Number(item.jumlah || item.quantity || 1),
        unitPrice: Number(item.harga || item.price || 0)
      })) : [],
      templateType: 'modern'
    };

    const invoice = await createInvoice(invoiceParams);
    logger.success('InvoiceAPI', 'Invoice generated successfully from order:', orderId);
    
    return invoice;
  } catch (error) {
    logger.error('InvoiceAPI', 'Failed to generate invoice from order:', error);
    throw error;
  }
};

/**
 * Generate invoice number
 */
const generateInvoiceNumber = async (): Promise<string> => {
  const now = new Date();
  const year = now.getFullYear();
  const month = String(now.getMonth() + 1).padStart(2, '0');
  
  // Simple sequential numbering for now
  const timestamp = Date.now();
  const sequence = String(timestamp).slice(-4);
  
  return `INV-${year}${month}-${sequence}`;
};

/**
 * Create invoice manually
 */
export const createInvoice = async (params: CreateInvoiceParams): Promise<Invoice> => {
  logger.context('InvoiceAPI', 'Creating invoice with params:', params);
  
  try {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) {
      throw new Error('User tidak terautentikasi');
    }

    // Generate invoice number
    const invoiceNumber = await generateInvoiceNumber();
    
    // Calculate totals
    const subtotal = params.items.reduce((sum, item) => sum + (item.quantity * item.unitPrice), 0);
    const discountAmount = params.discount ? 
      (params.discount.type === 'percentage' ? subtotal * params.discount.value / 100 : params.discount.value) : 0;
    const taxAmount = params.tax ? 
      (params.tax.type === 'percentage' ? (subtotal - discountAmount) * params.tax.value / 100 : params.tax.value) : 0;
    const totalAmount = subtotal - discountAmount + taxAmount + (params.shippingAmount || 0);

    // Create mock invoice for now since tables are not in schema
    const mockInvoice: Invoice = {
      id: self.crypto?.randomUUID() || `${Date.now()}-${Math.random().toString(36).substring(2, 11)}`,
      invoiceNumber,
      orderId: params.orderId,
      customerName: params.customerName,
      customerEmail: params.customerEmail,
      customerPhone: params.customerPhone,
      customerAddress: params.customerAddress,
      issueDate: params.issueDate ? new Date(params.issueDate) : new Date(),
      dueDate: params.dueDate ? new Date(params.dueDate) : undefined,
      subtotal,
      discountAmount,
      discountPercentage: params.discount?.type === 'percentage' ? params.discount.value : 0,
      taxAmount,
      taxPercentage: params.tax?.type === 'percentage' ? params.tax.value : 0,
      shippingAmount: params.shippingAmount || 0,
      totalAmount,
      status: 'draft',
      currency: params.currency || 'IDR',
      notes: params.notes,
      paymentInstructions: params.paymentInstructions,
      autoGenerated: params.autoGenerated || false,
      templateType: params.templateType || 'modern',
      items: params.items.map((item, index) => ({
        id: self.crypto?.randomUUID() || `${Date.now()}-${Math.random().toString(36).substring(2, 11)}`,
        itemName: item.itemName,
        description: item.description,
        quantity: item.quantity,
        unitPrice: item.unitPrice,
        totalPrice: item.quantity * item.unitPrice,
        sortOrder: index
      })),
      createdAt: new Date(),
      updatedAt: new Date()
    };

    logger.success('InvoiceAPI', 'Invoice created successfully:', mockInvoice.invoiceNumber);
    
    return mockInvoice;
  } catch (error) {
    logger.error('InvoiceAPI', 'Failed to create invoice:', error);
    throw error;
  }
};

/**
 * Get invoice by ID
 */
export const getInvoiceById = async (invoiceId: string): Promise<Invoice> => {
  logger.context('InvoiceAPI', 'Fetching invoice by ID:', invoiceId);
  
  try {
    // Mock implementation for now
    const mockInvoice: Invoice = {
      id: invoiceId,
      invoiceNumber: 'INV-202412-0001',
      orderId: undefined,
      customerName: 'Mock Customer',
      customerEmail: 'customer@example.com',
      customerPhone: '+62812345678',
      customerAddress: 'Mock Address',
      issueDate: new Date(),
      dueDate: undefined,
      subtotal: 100000,
      discountAmount: 0,
      discountPercentage: 0,
      taxAmount: 11000,
      taxPercentage: 11,
      shippingAmount: 0,
      totalAmount: 111000,
      status: 'draft',
      currency: 'IDR',
      notes: undefined,
      paymentInstructions: undefined,
      autoGenerated: false,
      templateType: 'modern',
      items: [{
        id: self.crypto?.randomUUID() || `${Date.now()}-${Math.random().toString(36).substring(2, 11)}`,
        itemName: 'Mock Item',
        description: 'Mock item description',
        quantity: 1,
        unitPrice: 100000,
        totalPrice: 100000,
        sortOrder: 0
      }],
      createdAt: new Date(),
      updatedAt: new Date()
    };

    logger.success('InvoiceAPI', 'Invoice fetched successfully:', mockInvoice.invoiceNumber);
    return mockInvoice;
  } catch (error) {
    logger.error('InvoiceAPI', 'Failed to fetch invoice:', error);
    throw error;
  }
};

/**
 * Get user invoices with pagination
 */
export const getUserInvoices = async (offset: number = 0, limit: number = 10): Promise<Invoice[]> => {
  logger.context('InvoiceAPI', 'Fetching user invoices');
  
  try {
    // Mock implementation for now
    const mockInvoices: Invoice[] = [
      {
        id: self.crypto?.randomUUID() || `${Date.now()}-${Math.random().toString(36).substring(2, 11)}`,
        invoiceNumber: 'INV-202412-0001',
        orderId: undefined,
        customerName: 'Mock Customer 1',
        customerEmail: 'customer1@example.com',
        customerPhone: '+62812345678',
        customerAddress: 'Mock Address 1',
        issueDate: new Date(),
        dueDate: undefined,
        subtotal: 100000,
        discountAmount: 0,
        discountPercentage: 0,
        taxAmount: 11000,
        taxPercentage: 11,
        shippingAmount: 0,
        totalAmount: 111000,
        status: 'draft',
        currency: 'IDR',
        notes: undefined,
        paymentInstructions: undefined,
        autoGenerated: false,
        templateType: 'modern',
        items: [],
        createdAt: new Date(),
        updatedAt: new Date()
      }
    ];

    logger.success('InvoiceAPI', `Fetched ${mockInvoices.length} invoices`);
    return mockInvoices;
  } catch (error) {
    logger.error('InvoiceAPI', 'Failed to fetch user invoices:', error);
    throw error;
  }
};

/**
 * Update invoice status
 */
export const updateInvoiceStatus = async (invoiceId: string, status: Invoice['status']): Promise<void> => {
  logger.context('InvoiceAPI', 'Updating invoice status:', { invoiceId, status });
  
  try {
    // Mock implementation for now
    logger.success('InvoiceAPI', 'Invoice status updated successfully');
  } catch (error) {
    logger.error('InvoiceAPI', 'Failed to update invoice status:', error);
    throw error;
  }
};

/**
 * Delete invoice
 */
export const deleteInvoice = async (invoiceId: string): Promise<void> => {
  logger.context('InvoiceAPI', 'Deleting invoice:', invoiceId);
  
  try {
    // Mock implementation for now
    logger.success('InvoiceAPI', 'Invoice deleted successfully');
  } catch (error) {
    logger.error('InvoiceAPI', 'Failed to delete invoice:', error);
    throw error;
  }
};
